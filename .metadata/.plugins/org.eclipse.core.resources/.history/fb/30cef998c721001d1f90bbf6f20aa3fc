package stringbuilder;

/**
 * [StringBuilder와 StringBuffer 클래스]
 * 1. String 클래스
 * 	 //아래 2개 : 배열 선언 시 같은 표현
 * 	  private final char value[];
 * 	  private final char[] value;
 * 	 => String 클래스는 한번 생성되면 내부의 문자열 값이 변경되지 않기 때문에
 * 	 문자열 concat() 또는 +로 연결하거나
 * 	 subString() 등과 같은 메서드로 변경하면
 * 	 항상 "새로운 문자열 객체가 생성"되어 메모리의 낭비가 심하다.
 *
 *	※ 위 문제를 해결하기 위해서 StringBuilder와 StringBuffer 클래스 등장함
 *
 *	2. StringBuilder와 StringBuffer 클래스의 유일한 차이점
 *	 - StringBuilder : 싱글 쓰레드에서 사용 -> 속도 향상
 *	 - StringBuffer  : 멀티 쓰레드에서 사용 -> 동기화 보장
 */
public class StringBuilderTest { //373p_교재_참조

	public static void main(String[] args) {
		String javaStr = new String("Java");
		//처음 생성된 메모리 실제 주소
		System.out.println("[처음] javaStr 문자열 실제주소 : " + System.identityHashCode(javaStr));
		
		javaStr = javaStr.concat(" and JSP"); //문자열 연결
		System.out.println("[추가 후] javaStr 문자열 실제주소 : " + System.identityHashCode(javaStr));
		
		javaStr = javaStr.replace("Java", "Java program"); //문자열 대체
		System.out.println("[대체 후] javaStr 문자열 실제주소 : " + System.identityHashCode(javaStr));
		
		System.out.println(javaStr);
		
		System.out.println("----------------------------------------");
		
		//"Java and JSP" String으로부터 StringBuilder 객체 생성		
		//StringBuilder stringBuilder = new StringBuilder(javaStr);
		StringBuilder stringBuilder = new StringBuilder();
		System.out.println("[처음] StringBuilder 실제주소 : " + System.identityHashCode(stringBuilder));
		
		stringBuilder.append("Java and JSP");		//문자열 추가
		stringBuilder.append(" and"); 		//문자열 추가
		stringBuilder.append(" android"); //문자열 추가
		
		stringBuilder.insert(4, " program ");
		
		System.out.println("[수정 후] StringBuilder 실제주소 : " + System.identityHashCode(stringBuilder));
		
		javaStr = stringBuilder.toString(); //추가할 문자열들을 다 추가 후 String객체로 변환
		System.out.println(javaStr);
		
		System.out.println("새로 만들어진 javaStr 문자열 실제 주소 : " + System.identityHashCode(javaStr));
		
	}

}
